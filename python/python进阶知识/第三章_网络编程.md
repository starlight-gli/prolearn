## 第三章  网络编程

### 第一节  网络介绍

* **内容简介**

  网络就是一种辅助双方或者多方能够连接在一起的工具，试想一下，如果没有网络，这个世界将会是什么样子的。

* **要点展示**

* **名词拓展**

  [三次握手 ，ip地址 ，端口号 ， tcp协议 ， https协议 ]

  [mac地址 ， ip地址 ，子网掩码 ，默认网关 ，集线器 ， 交换机 ，路由器 ，

   DNS ， http服务器 ]

  解包，握手，请求，回应，展示

  DNS 是把域名转化成ip地址

  子网掩码区分主机地址和网络地址

---

#### 网络通信过程

#### TCP/IP介绍

1. ip地址

2. 端口号

   ip+config：IP 地址的端口可以有 65536（即：2^16）。按端口分配数据。

3. 域名

   域名是ip地址的映射。

#### TCP/IP协议

* **TCP传输控制协议**
* **UDP用户数据报协议**

##### socket的概念

​	socket (简称 套接字) 是 **进程之间通信一个工具**，好比现实生活中的 **插座**，所有的家用电器要想工作都是基于插座进行， **进程之间想要进行网络通信需要基于这个 socket**。

![socket](https://cdn.jsdelivr.net/gh/starlight-gli/image-host/img/socket2.CTS_bA3v.png)

​	不夸张的说，只要跟 **网络相关的应用程序或者软件都使用到了 socket** 。

![assets](https://cdn.jsdelivr.net/gh/starlight-gli/image-host/img/05225723-2ffa89aad91f46099afa530ef8660b20.6Q5UbAS1.jpg)



---

### 第二节  Python网络编程

* **内容简介**

* **要点展示**

  [socket,socketsever,]

* **名词拓展**

  [套接字，ICMP，IGMP]

---

socket

socketsever

C/S架构：客户端、服务器

B/S架构：浏览器、服务器

#### `socket`模块

python 网络编程的主要使用模块为 `socket` 模块。使用`socket(family, type[,protocal])` 使用给定的套接族，套接字类型，协议编号（默认为 0）就可以创建套接字

- `family`：协议版本

- `protocal`：通信协议

  | socket 类型             | 描述                                                         |
  | :---------------------- | :----------------------------------------------------------- |
  | `socket.AF_UNIX`        | 用于同一台机器上的进程通信（既本机通信）                     |
  | `socket.AF_INET`        | 用于服务器与服务器之间的网络通信                             |
  | `socket.AF_INET6`       | 基于 `IPV6` 方式的服务器与服务器之间的网络通信               |
  | `socket.SOCK_STREAM`    | 基于 TCP 的流式 socket 通信                                  |
  | `socket.SOCK_DGRAM`     | 基于 `UDP` 的数据报式 socket 通信                            |
  | `socket.SOCK_RAW`       | 原始套接字，普通的套接字无法处理 `ICMP`、`IGMP` 等网络报文，而 SOCK_RAW 可以；其次 SOCK_RAW 也可以处理特殊的 `IPV4` 报文；此外，利用原始套接字，可以通过 `IP_HDRINCL` 套接字选项由用户构造 `IP` 头 |
  | `socket.SOCK_SEQPACKET` | 可靠的连续数据包服务                                         |

* 服务器端socket函数

  | Socket 函数         | 描述                                                         |
  | :------------------ | :----------------------------------------------------------- |
  | `s.bind(address)`   | 将套接字绑定到地址，在 `AF_INET` 下，以 `tuple(host, port)` 的方式传入，如`s.bind((host, port))` |
  | `s.listen(backlog)` | 开始监听 TCP 传入连接，backlog 指定在拒绝链接前，操作系统可以挂起的最大连接数，该值最少为 1，大部分应用程序设为 5 就够用了 |
  | `s.accept()`        | 接受 TCP 链接并返回（conn, address），其中 conn 是新的套接字对象，可以用来接收和发送数据，address 是链接客户端的地址。 |

* 客户端socket函数

  | Socket 函数             | 描述                                                         |
  | :---------------------- | :----------------------------------------------------------- |
  | `s.connect(address)`    | 链接到 address 处的套接字，一般 address 的格式为 `tuple(host, port)`，如果链接出错，则返回 `socket.error` 错误 |
  | `s.connect_ex(address)` | 功能与 `s.connect(address)` 相同，但成功返回 0，失败返回 `errno` 的值 |

* 公共socket函数

  | Socket 函数                              | 描述                                                         |
  | :--------------------------------------- | :----------------------------------------------------------- |
  | `s.recv(bufsize[, flag])`                | 接受 `TCP` 套接字的数据，数据以字符串形式返回，`buffsize` 指定要接受的最大数据量，`flag` 提供有关消息的其他信息，通常可以忽略 |
  | `s.send(string[, flag])`                 | 发送 `TCP` 数据，将字符串中的数据发送到链接的套接字，返回值是要发送的字节数量，该数量可能小于 `string` 的字节大小 |
  | `s.sendall(string[, flag])`              | 完整发送 `TCP` 数据，将字符串中的数据发送到链接的套接字，但在返回之前尝试发送所有数据。成功返回 `None`，失败则抛出异常 |
  | `s.recvfrom(bufsize[, flag])`            | 接受 `UDP` 套接字的数据，与 `recv()` 类似，但返回值是 `tuple(data, address)`。其中 `data` 是包含接受数据的字符串，`address` 是发送数据的套接字地址 |
  | `s.sendto(string[, flag], address)`      | 发送 `UDP` 数据，将数据发送到套接字，`address` 形式为 `tuple(ipaddr, port)` ，指定远程地址发送，返回值是发送的字节数 |
  | `s.close()`                              | 关闭套接字                                                   |
  | `s.getpeername()`                        | 返回套接字的远程地址，返回值通常是一个 `tuple(ipaddr, port)` |
  | `s.getsockname()`                        | 返回套接字自己的地址，返回值通常是一个 `tuple(ipaddr, port)` |
  | `s.setsockopt(level, optname, value)`    | 设置给定套接字选项的值                                       |
  | `s.getsockopt(level, optname[, buflen])` | 返回套接字选项的值                                           |
  | `s.settimeout(timeout)`                  | 设置套接字操作的超时时间，`timeout` 是一个浮点数，单位是秒，值为 `None` 则表示永远不会超时。一般超时期应在刚创建套接字时设置，因为他们可能用于连接的操作，如 `s.connect()` |
  | `s.gettimeout()`                         | 返回当前超时值，单位是秒，如果没有设置超时则返回 None        |
  | `s.fileno()`                             | 返回套接字的文件描述                                         |
  | `s.setblocking(flag)`                    | 如果 flag 为 0，则将套接字设置为非阻塞模式，否则将套接字设置为阻塞模式（默认值）。非阻塞模式下，如果调用 `recv()` 没有发现任何数据，或 `send()` 调用无法立即发送数据，那么将引起 `socket.error` 异常。 |
  | `s.makefile()`                           | 创建一个与该套接字相关的文件                                 |
  
  **网络编程建立过程 **
  
  1. `socket` 创建一个套接字
  
  2. `bind` 绑定 `ip` 和 `port`
  
  3. `listen` 使套接字变为可以被动链接
  
  4. `accept` 等待客户端的链接
  
  5. `recv/send` 接收发送数据
  
     

#### `socket`编程思想

* socket通信流程

  打开--读/写--关闭

  

### 第三节  基础概念

* **内容简介**

* **要点展示**

* **名词拓展**

### 第四节  网络编程_练习

* **内容简介**

* **要点展示**

* **名词拓展**

### 第五节  案例_网络聊天室

* **内容简介**

* **要点展示**

* **名词拓展**

### 第六节  附录

* **内容简介**

* **要点展示**

* **名词拓展**




## 第四章  并发编程_多线程

### 第一节  多线程介绍

### 第二节  执行顺序

### 第三节  无锁不安装

### 第四节  队列

### 第五节   多线程_练习

**名词拓展**

[并发与并行，发送缓存区，数据缓存区，]

- **threading.current_thread()**: 返回当前的线程变量。
- **threading.enumerate()**: 返回一个包含正在运行的线程的列表。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。
- **threading.active_count()**: 返回正在运行的线程数量，与 len(threading.enumerate()) 有相同的结果。
- **threading.Thread(target, args=(), kwargs={}, daemon=None)**：



threading.Thread 类提供了以下方法与属性:

1. **`__init__(self, group=None, target=None, name=None, args=(), kwargs={},*, daemon=None)`：**
   - 初始化`Thread`对象。
   - `group`：线程组，暂时未使用，保留为将来的扩展。
   - `target`：线程将要执行的目标函数。
   - `name`：线程的名称。
   - `args`：目标函数的参数，以元组形式传递。
   - `kwargs`：目标函数的关键字参数，以字典形式传递。
   - `daemon`：指定线程是否为守护线程。
2. **`start(self)`：**
   - 启动线程。将调用线程的`run()`方法。
3. **`run(self)`：**
   - 线程在此方法中定义要执行的代码。
4. **`join(self, timeout=None)`：**
   - 等待线程终止。默认情况下，`join()`会一直阻塞，直到被调用线程终止。如果指定了`timeout`参数，则最多等待`timeout`秒。
5. **`is_alive(self)`：**
   - 返回线程是否在运行。如果线程已经启动且尚未终止，则返回`True`，否则返回`False`。
6. **`getName(self)`：**
   - 返回线程的名称。
7. **`setName(self, name)`：**
   - 设置线程的名称。
8. **`ident`属性：**
   - 线程的唯一标识符。
9. **`daemon`属性：**
   - 线程的守护标志，用于指示是否是守护线程。
10. **`isDaemon()`方法：**

![多线程 socket 服务器](https://docs.zhengxinonly.com/assets/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-socket%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1.ByNR2V6k.svg)
